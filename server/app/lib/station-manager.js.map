{"version":3,"sources":["lib/station-manager.js"],"names":["Promise","require","EventEmitter","StationManager","nconf","logger","hilbertCLI","mkLivestatus","events","logEntries","lastLogID","globalHilbertCLIOutputBuffer","lastMKLivestatusDump","clearStations","loadStationConfig","then","pollLoopBody","pollDelay","get","consecutiveErrors","errorDigestSize","pollMKLivestatus","setTimeout","catch","error","signalUpdate","getStationConfig","stationsCFG","stationCFG","addStation","aStation","verbose","id","stationList","push","stationIndex","set","i","indexOf","splice","delete","Map","stationIDs","eligibleStations","stationID","station","getStationByID","setQueuedToStartState","map","eligibleStation","setStartingState","startStation","outputBuffer","log","setErrorState","concurrency","setQueuedToStopState","setStoppingState","stopStation","appID","setQueuedToChangeAppState","setChangingAppState","changeApp","type","message","newLogEntry","time","Date","toISOString","station_id","station_name","name","maxEntries","length","slice","getState","allStationsStatus","lastState","changes","stationStatus","updateFromMKLivestatus","emit"],"mappings":"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","file":"lib/station-manager.js","sourcesContent":["const Promise = require('bluebird');\nconst EventEmitter = require('events').EventEmitter;\n\nimport Station from './station';\nimport TerminalOutputBuffer from './terminal-output-buffer';\n\n/**\n * Service Layer for hilbert\n * Dispatches requests asynchronously and keeps cached state\n */\nexport default class StationManager {\n\n  /**\n   * Create a Station Manager\n   *\n   * @param {Object} nconf - Instance of nconf configuration\n   * @param {Object} logger - Instance of winston logger\n   * @param {HilbertCLIConnector} hilbertCLI - hilbert-cli connector\n   * @param {MKLivestatusConnector} mkLivestatus - MKLivestatus connector\n   */\n  constructor(nconf, logger, hilbertCLI, mkLivestatus) {\n    this.nconf = nconf;\n    this.logger = logger;\n\n    this.hilbertCLI = hilbertCLI;\n    this.mkLivestatus = mkLivestatus;\n\n    this.events = new EventEmitter();\n    this.logEntries = [];\n    this.lastLogID = 1;\n\n    this.globalHilbertCLIOutputBuffer = new TerminalOutputBuffer();\n    this.lastMKLivestatusDump = [];\n\n    this.clearStations();\n  }\n\n  /**\n   * Reads the station configuration and begins polling station status\n   *\n   * @return {Promise}\n   */\n  init() {\n    return this.loadStationConfig().then(() => {\n      const pollLoopBody = () => {\n        const pollDelay = this.nconf.get('mkls_poll_delay');\n        let consecutiveErrors = 0;\n        const errorDigestSize = 50;\n        this.pollMKLivestatus().then(() => {\n          consecutiveErrors = 0;\n          setTimeout(pollLoopBody, pollDelay);\n        }).catch(() => {\n          if (consecutiveErrors % errorDigestSize) {\n            if (consecutiveErrors !== 0) {\n              this.logger.error(\n                `Station manager: Repeated MKLivestatus polling errors (${errorDigestSize} times)`);\n            }\n          }\n          consecutiveErrors++;\n          setTimeout(pollLoopBody, pollDelay);\n        });\n      };\n      pollLoopBody();\n    });\n  }\n\n  /**\n   * Loads the station configuration.\n   *\n   * If the configuration was already loaded this method clears it\n   * and reloads everything\n   *\n   * @returns {Promise}\n   */\n  loadStationConfig() {\n    this.clearStations();\n    this.signalUpdate();\n\n    return this.hilbertCLI.getStationConfig(this.globalHilbertCLIOutputBuffer).then((stationsCFG) => {\n      for (const stationCFG of stationsCFG) {\n        this.addStation(new Station(stationCFG));\n      }\n      this.signalUpdate();\n    });\n  }\n\n  /**\n   * Adds a station to the manager\n   * @param {Station} aStation\n   */\n  addStation(aStation) {\n    this.logger.verbose(`Station manager: Adding station ${aStation.id}`);\n    this.stationList.push(aStation);\n    this.stationIndex.set(aStation.id, aStation);\n  }\n\n  /**\n   * Removes a station from the manager\n   * @param {Station} aStation\n   */\n  removeStation(aStation) {\n    this.logger.verbose(`Station manager: Removing station ${aStation.id}`);\n    const i = this.stationList.indexOf(aStation);\n    if (i !== -1) {\n      this.stationList.splice(i, 1);\n    }\n\n    this.stationIndex.delete(aStation.id);\n  }\n\n  /**\n   * Removes all the stations\n   */\n  clearStations() {\n    this.logger.verbose('Station manager: Clearing all stations');\n    this.stationIndex = new Map();\n    this.stationList = [];\n  }\n\n  /**\n   * Get the ordered list of stations\n   * @returns {Array}\n   */\n  getStations() {\n    return this.stationList;\n  }\n\n  /**\n   * Return a station identified by ID\n   *\n   * @param {string} id - Station ID\n   * @returns {Station}\n   */\n  getStationByID(id) {\n    return this.stationIndex.get(id);\n  }\n\n  /**\n   * Start indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to start\n   * @return {Promise}\n   */\n  startStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStartState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Starting station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStartingState();\n        this.signalUpdate();\n        return this.hilbertCLI.startStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Station ${eligibleStation} started`);\n          this.log('message', station, 'Station started');\n        })\n        .catch(() => {\n          this.logger.verbose(`Station manager: Station ${eligibleStation} failed to start`);\n          this.log('error', station, 'Error starting station');\n          station.setErrorState('Failure starting the station');\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Stop indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations to stop\n   * @return {Promise}\n   */\n  stopStations(stationIDs) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToStopState()) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(`Station manager: Stopping station ${eligibleStation}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setStoppingState();\n        this.signalUpdate();\n        return this.hilbertCLI.stopStation(station.id, station.outputBuffer).then(() => {\n          this.logger.verbose(`Station manager: Station ${eligibleStation} stopped`);\n          this.log('message', station, 'Station stopped');\n        })\n          .catch(() => {\n            this.logger.verbose(`Station manager: Station ${eligibleStation} failed to stop`);\n            this.log('error', station, 'Error stopping station');\n            station.setErrorState('Failure stopping the station');\n          })\n          .then(() => {\n            this.signalUpdate();\n          });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Change the application running in indicated stations\n   *\n   * @param {Iterable} stationIDs - IDs of stations in which to change the appID\n   * @param {string} appID - Name of the appID to run\n   * @return {Promise}\n   */\n  changeApp(stationIDs, appID) {\n    const eligibleStations = [];\n    for (const stationID of stationIDs) {\n      const station = this.getStationByID(stationID);\n      if (station && station.setQueuedToChangeAppState(appID)) {\n        eligibleStations.push(stationID);\n      }\n    }\n\n    this.signalUpdate();\n\n    return Promise.map(\n      eligibleStations,\n      (eligibleStation) => {\n        this.logger.verbose(\n          `Station manager: Changing app of station ${eligibleStation} to ${appID}`);\n        const station = this.getStationByID(eligibleStation);\n        station.setChangingAppState(appID);\n        this.signalUpdate();\n        return this.hilbertCLI.changeApp(eligibleStation, appID, station.outputBuffer).then(() => {\n          this.logger.verbose(\n            `Station manager: Changed app of station ${eligibleStation} to ${appID}`);\n          this.log('message', station, `Launched app ${appID}`);\n        })\n        .catch(() => {\n          this.logger.verbose(\n            `Station manager: Failed changing app of station ${eligibleStation} to ${appID}`);\n          this.log('error', station, `Failed to launch app ${appID}`);\n          station.setErrorState(`Failed to open ${appID}`);\n        })\n        .then(() => {\n          this.signalUpdate();\n        });\n      },\n      { concurrency: this.nconf.get('scriptConcurrency') }\n    );\n  }\n\n  /**\n   * Return the station activity log\n   *\n   * Each log entry is an object with the following structure:\n   * - id {string} : Unique id of the entry\n   * - time {string} : Timestamp in ISO format\n   * - type {string} : info | warning | error\n   * - message {string} : Event description\n   *\n   * @returns {Array}\n   */\n  getLog() {\n    return this.logEntries;\n  }\n\n\n  /**\n   * Logs an event\n   *\n   * @param {string} type - Event type: info | warning | error\n   * @param {Station|null} station - station associated with the event logged\n   * @param {string} message - Message to log\n   */\n  log(type, station, message) {\n    const newLogEntry = {\n      id: this.lastLogID,\n      time: new Date().toISOString(),\n      type,\n      message,\n    };\n\n    if (station !== null) {\n      newLogEntry.station_id = station.id;\n      newLogEntry.station_name = station.name;\n    }\n\n    this.lastLogID++;\n    this.logEntries.push(newLogEntry);\n\n    const maxEntries = this.nconf.get('max_log_length');\n    if (this.logEntries.length > maxEntries) {\n      this.logEntries = this.logEntries.slice(this.logEntries.length - maxEntries);\n    }\n  }\n\n  /**\n   * Polls MKLivestatus and updates the state of stations\n   * @returns {Promise}\n   */\n  pollMKLivestatus() {\n    return this.mkLivestatus.getState().then((allStationsStatus) => {\n      const lastState = [];\n      let changes = false;\n      for (const stationStatus of allStationsStatus) {\n        lastState.push(stationStatus);\n        const station = this.getStationByID(stationStatus.id);\n        if (station) {\n          if (station.updateFromMKLivestatus(stationStatus)) {\n            changes = true;\n          }\n        }\n      }\n      this.lastMKLivestatusDump = lastState;\n\n      if (changes) {\n        this.signalUpdate();\n      }\n    });\n  }\n  /**\n   * Signal listeners that station data was modified\n   * @private\n   */\n  signalUpdate() {\n    this.events.emit('stationUpdate');\n  }\n}\n"],"sourceRoot":"/source/"}